"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var React = require('react');
var TextField_1 = require('material-ui/TextField');
var ObjectAssign = require('object-assign');
function getChangeEvent(event) {
    return {
        bubbles: event.bubbles,
        cancelable: event.cancelable,
        currentTarget: event.currentTarget,
        defaultPrevented: event.defaultPrevented,
        eventPhase: event.eventPhase,
        isTrusted: event.isTrusted,
        nativeEvent: event.nativeEvent,
        preventDefault: event.preventDefault,
        isDefaultPrevented: event.isDefaultPrevented,
        stopPropagation: event.stopPropagation,
        isPropagationStopped: event.isPropagationStopped,
        persist: event.persist,
        target: event.target,
        timeStamp: event.timeStamp,
        type: 'change',
    };
}
function allowedError(error) {
    return (error === 'none') || (error === 'incompleteNumber') || (error === 'clean') || (error === 'required');
}
function removeLastChar(value) {
    return value.substring(0, value.length - 1);
}
var NumberInput = (function (_super) {
    __extends(NumberInput, _super);
    function NumberInput(props) {
        _super.call(this, props);
        this.state = { error: undefined };
        this._onKeyDown = this._handleKeyDown.bind(this);
        this._onChange = this._handleChange.bind(this);
        this._onBlur = this._handleBlur.bind(this);
    }
    NumberInput.prototype._emitEvents = function (nextError, value, valid) {
        if (valid === void 0) { valid = true; }
        var _a = this, props = _a.props, state = _a.state;
        var onError = props.onError, onValid = props.onValid, strategy = props.strategy;
        var error = state.error;
        if ((error !== nextError)) {
            if ((onError !== undefined) && (strategy !== 'ignore') && (nextError !== 'limit')) {
                onError(nextError);
            }
            this.setState({ error: nextError });
        }
        if ((nextError === 'none') && (onValid !== undefined) && valid) {
            onValid(Number(value));
        }
    };
    NumberInput.prototype._validateNumberValue = function (value) {
        var _a = this.props, max = _a.max, min = _a.min;
        if ((max !== undefined) && (value > max)) {
            return 1;
        }
        if ((min !== undefined) && (value < min)) {
            return -1;
        }
        return 0;
    };
    NumberInput.prototype._validateValue = function (value) {
        var props = this.props;
        var required = props.required, strategy = props.strategy, max = props.max, min = props.min;
        if (value === '') {
            return required ? 'required' : 'clean';
        }
        else {
            if (value.match(/^(\-|\.|\d)+$/)) {
                if (value.match(/^-?((0|([1-9]\d{0,}))(\.\d{0,})?)?$/)) {
                    if (value.match(/^-?((0(\.\d+)?)|([1-9]\d{0,}(\.\d+)?))$/)) {
                        switch (this._validateNumberValue(Number(value))) {
                            case 1: return 'max';
                            case -1: return 'min';
                            default: return 'none';
                        }
                    }
                    else {
                        var checkLimit = parseFloat(removeLastChar(value));
                        return ((strategy === 'ignore') && ((checkLimit === max) || (checkLimit === min))) ? 'limit' : 'incompleteNumber';
                    }
                }
                else {
                    var last = value[value.length - 1];
                    var error = void 0;
                    switch (last) {
                        case '-':
                            error = 'singleMinus';
                            break;
                        case '.':
                            error = 'singleFloatingPoint';
                            break;
                        default:
                            error = 'singleZero';
                            break;
                    }
                    return error;
                }
            }
            else {
                return 'invalidSymbol';
            }
        }
    };
    NumberInput.prototype._validateAndEmit = function (value, valid) {
        if (valid === void 0) { valid = true; }
        this._emitEvents(this._validateValue(value), value, valid);
    };
    NumberInput.prototype._handleKeyDown = function (event) {
        var key = event.key;
        var _a = this.props, onKeyDown = _a.onKeyDown, strategy = _a.strategy;
        var canCallOnKeyDown = onKeyDown !== undefined;
        var emitKeyDown = function () {
            if (canCallOnKeyDown) {
                onKeyDown(event);
            }
        };
        if (key.length === 1) {
            var eventValue = event;
            var value = eventValue.target.value;
            var nextValue = key.length === 1 ? value + key : value;
            var error = this._validateValue(nextValue);
            if ((strategy !== 'allow') && !allowedError(error)) {
                event.preventDefault();
                if (strategy === 'warn') {
                    this._emitEvents(error, nextValue);
                }
            }
            else {
                emitKeyDown();
            }
        }
        else {
            emitKeyDown();
        }
    };
    NumberInput.prototype._handleChange = function (event) {
        var eventValue = event;
        var value = eventValue.target.value;
        var _a = this, props = _a.props, state = _a.state;
        var onChange = props.onChange, strategy = props.strategy, propsValue = props.value;
        var error = state.error;
        if (onChange !== undefined) {
            onChange(event, value);
        }
        if (propsValue === undefined) {
            this._validateAndEmit(value);
        }
    };
    NumberInput.prototype._handleBlur = function (event) {
        var eventValue = event;
        var strategy = this.props.strategy;
        if (strategy === 'warn') {
            this._validateAndEmit(eventValue.target.value, false);
        }
    };
    NumberInput.prototype.getInputNode = function () {
        return this.textField.getInputNode();
    };
    NumberInput.prototype.componentDidMount = function () {
        var value = this.props.value;
        if (value !== undefined) {
            this._validateAndEmit(value);
        }
    };
    NumberInput.prototype.componentWillReceiveProps = function (props) {
        var value = props.value;
        if (value !== this.props.value) {
            this._validateAndEmit(value);
        }
    };
    NumberInput.prototype.render = function () {
        var _this = this;
        var _a = this, props = _a.props, state = _a.state, _onKeyDown = _a._onKeyDown, _onChange = _a._onChange, _onBlur = _a._onBlur;
        var value = props.value, defaultValue = props.defaultValue, strategy = props.strategy;
        var error = state.error;
        var shouldOverwrite = (value !== undefined) && (strategy === 'ignore') && !allowedError(error);
        var newValue = shouldOverwrite ? (error !== 'limit' ? '' : removeLastChar(value)) : value;
        var clonedProps = ObjectAssign({}, props);
        if (clonedProps.strategy !== undefined) {
            delete clonedProps.strategy;
        }
        if (clonedProps.onError !== undefined) {
            delete clonedProps.onError;
        }
        if (clonedProps.onValid !== undefined) {
            delete clonedProps.onValid;
        }
        return React.cloneElement(React.createElement(TextField_1.default, null), ObjectAssign(clonedProps, {
            type: 'text',
            defaultValue: defaultValue === undefined ? defaultValue : String(defaultValue),
            value: newValue,
            onKeyDown: _onKeyDown,
            onChange: _onChange,
            onBlur: _onBlur,
            ref: function (textField) { _this.textField = textField; }
        }));
    };
    NumberInput.propTypes = {
        children: React.PropTypes.node,
        className: React.PropTypes.string,
        disabled: React.PropTypes.bool,
        errorStyle: React.PropTypes.object,
        errorText: React.PropTypes.node,
        floatingLabelFixed: React.PropTypes.bool,
        floatingLabelFocusStyle: React.PropTypes.object,
        floatingLabelStyle: React.PropTypes.object,
        floatingLabelText: React.PropTypes.node,
        fullWidth: React.PropTypes.bool,
        hintStyle: React.PropTypes.object,
        hintText: React.PropTypes.node,
        id: React.PropTypes.string,
        inputStyle: React.PropTypes.object,
        name: React.PropTypes.string,
        onBlur: React.PropTypes.func,
        onChange: React.PropTypes.func,
        onFocus: React.PropTypes.func,
        onErrro: React.PropTypes.func,
        onKeyDown: React.PropTypes.func,
        style: React.PropTypes.object,
        underlineDisabledStyle: React.PropTypes.object,
        underlineFocusStyle: React.PropTypes.object,
        underlineShow: React.PropTypes.bool,
        underlineStyle: React.PropTypes.object,
        defaultValue: React.PropTypes.number,
        min: React.PropTypes.number,
        max: React.PropTypes.number,
        required: React.PropTypes.bool,
        strategy: React.PropTypes.oneOf(['ignore', 'warn', 'allow']),
        value: React.PropTypes.string
    };
    NumberInput.defaultProps = { required: false, strategy: 'allow' };
    return NumberInput;
}(React.Component));
exports.NumberInput = NumberInput;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = NumberInput;
